const path=require("path"),fs=require("fs-extra"),{readYaml,tryReadYaml}=require("../utils"),{default:slugifyOriginal}=require("slugify"),isRelativeUrl=require("is-relative-url"),{slash}=require("gatsby-core-utils"),{downloadRegistryAssets}=require("../../../utils/registryAssets"),{getDirectoryPermission,GUEST_PERMISSION}=require("../rbac"),{findConfig}=require("@redocly/openapi-core"),CATALOG_FILE="catalog.yaml",LEGACY_DOMAIN="redoc.ly";function slugify(a){return slugifyOriginal(a).toLowerCase()}let resolvedApis=[];const catalogCache=new Map,versionsCache=new Map;module.exports={initCatalog,getCatalogInfo,getResolvedApis};function getResolvedApis(){return resolvedApis}function getCatalogInfo(a){const b=catalogCache.get(slash(a));return b?{...b,resolvedVersions:b.versions.map(a=>versionsCache.get(a.link)),resolvedDefaultVersion:versionsCache.get(b.defaultVersion.link)}:void 0}async function initCatalog({configPath:a,getSiteConfig:b},c){const d=path.resolve(a,CATALOG_FILE);if(fs.existsSync(d)){c.info("Initializing catalog.yaml");try{const b=await readYaml(d);if(!b||!b.apiCatalog)return;if(!Array.isArray(b.apiCatalog))throw new Error(`"apiCatalog" must be an array, got ${typeof b.apiCatalog} instead at catalog.yaml`);await prepareCatalogInfoCache(b,a,c)}catch(a){c.panicOnBuild(`Failed to initialize catalog.yaml: ${a.message}\n\n${a.stack}`)}}}async function downloadAssets(a,b,c,d,e){let g;try{g=await downloadRegistryAssets(a,b,d,e)}catch(a){throw new Error(`Error while downloading assets: ${a.message}`)}if(!g)throw new Error("Assets should have at least one file");let h,i=!1;for(const j of g){if(j.endsWith("/sidebars.yaml")&&(i=!0),!j.endsWith(".yaml")&&!j.endsWith(".yml"))continue;const a=await tryReadYaml(j);a&&(a.swagger||a.openapi)&&(h=path.relative(c,j))}if(h)return{files:g,definitionFileRelativePath:h,hasSidebars:i};throw new Error("Assets should have at least one openapi file")}async function prepareCatalogInfoCache(a,b,c){resolvedApis=[];const d=a.apiCatalog;for(const e of d){const a=e&&e.versions;if(!a||!Array.isArray(a))throw new Error(`"versions" is required in every API record at catalog.yaml`);const d=a.map(b=>{const c=parseLink(b.link);if(!c.isRemote||!c.apiName||!c.versionName)throw new Error("Local files are not supported by catalog yet");const d=b.version||c.versionName;if(!d&&1<a.length)throw new Error(`"version" field is required for local API versions: ${b.link}`);return{...b,version:d,apiName:c.apiName,isRemote:c.isRemote,summary:b.summary||d,parsedLink:c}}),f=e.defaultVersion||d[d.length-1].version,g=1<d.length?d.find(a=>a.version===f):d[d.length-1];if(!g)throw new Error(`Invalid defaultVersion "${f}", no corresponding version in versions list`);const h=e.pathPrefix?e.pathPrefix:slugify(g.apiName);for(const a of d){const d=a===g?"":"/"+slugify(a.version),f=h+d,i=a===g,{files:j,definitionFileRelativePath:k,hasSidebars:l}=await downloadAssets(a.link,f,b,c,!i);!i||l||e.disableAutoSidebar||(c.info(`Generating automatic sidebars for ${a.link}`),fs.writeFileSync(path.join(b,h,"sidebars.yaml"),"# Automatically generated file, do not edit\n- page: ./*"));const m=await tryReadYaml(findConfig(path.join(b,f))),n={title:e.title,redoclyYaml:{...m,lint:void 0},defaultVersion:g,versionInfo:a,versions:e.versions,apiName:a.apiName,apiVersion:a.version,versionRelativePath:f,isDefault:i,apiPathPrefix:"/"+path.join(path.dirname(k),path.basename(k).split(".")[0])};versionsCache.set(a.link,n);for(const a of j)catalogCache.set(slash(a),n)}c.info(`Generating automatic .gitignore for ${g.apiName}`),fs.writeFileSync(path.join(b,h,".gitignore"),"# Automatically generated file, do not edit\n# All catalog files should not be committed to source control.\n\n*");const i=versionsCache.get(g.link),j=versionInfoToResolvedCatalog(i,void 0);resolvedApis.push({title:e.title||g.apiName,defaultVersion:j,name:g.apiName,pathPrefix:"/"+h,permission:getDirectoryPermission(b,path.join(b,h))||GUEST_PERMISSION,versions:e.versions.map(a=>{const b=versionsCache.get(a.link);return versionInfoToResolvedCatalog(b,j)})})}}function versionInfoToResolvedCatalog(a,b){if(!a)throw new Error("Something went wrong");const c=a.redoclyYaml["features.catalog"]||{};return{summary:a.versionInfo.summary||a.apiVersion,apiName:a.apiName,isDefault:a.isDefault,metadata:c.metadata||{},pathPrefix:b?b.pathPrefix+(a.isDefault?"":"/"+a.apiVersion):a.apiPathPrefix,apiVersion:a.apiVersion,link:"",id:`${a.apiName}@${a.apiVersion}`,versionRelativePath:a.versionRelativePath}}function parseLink(a){if(isRelativeUrl(a))return{isRemote:!1,relativePath:a};else{const{pathname:b,hostname:c}=new URL(a),d=process.env.REDOCLY_DOMAIN||"redocly.com";if(`api.${d}`!==c&&`api.${LEGACY_DOMAIN}`!==c)throw new Error(`non-Redocly URLs are not supported "${a}"`);const[,e,f,g,h]=b.slice(1).split("/");if("assets"!==e)throw new Error("only URLs to assets are supported");if(!h)throw new Error(`Invalid asset link: ${a}`);return{isRemote:!0,orgName:f,apiName:g,versionName:h}}}